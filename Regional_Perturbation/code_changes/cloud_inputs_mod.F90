! *****************************COPYRIGHT**************************************
! (C) Crown copyright Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
! *****************************COPYRIGHT**************************************
!  data module for switches/options concerned with the cloud scheme.
  ! Description:
  !   Module containing runtime options/data used by the cloud scheme
  !
  ! Method:
  !   Switches and associated data values used by the cloud scheme
  !   are defined here and assigned default values. These may be overridden
  !   by namelist input.
  !
  !   A description of what each switch or number refers to is provided
  !   with the namelist
  !
  !   Any routine wishing to use these options may do so with the 'USE'
  !   statement.
  !
  ! Code Owner: Please refer to the UM file CodeOwners.txt
  ! This file belongs in section: Large Scale Cloud
  !
  ! Code Description:
  !   Language: FORTRAN 90
  !

MODULE cloud_inputs_mod

USE missing_data_mod, ONLY: rmdi, imdi
USE atmos_max_sizes,  ONLY: model_levels_max
USE yomhook,  ONLY: lhook, dr_hook
USE parkind1, ONLY: jprb, jpim
USE errormessagelength_mod, ONLY: errormessagelength

IMPLICIT NONE

!===========================================================================
! INTEGER options set from RUN_CLOUD namelist
!===========================================================================

INTEGER :: i_cld_vn = imdi
! Which cloud scheme are we using - Off (microphysics only), Smith of PC2

INTEGER :: falliceshear_method = imdi
                                       ! Select method for including
                                       ! effects of shear on falling
                                       ! ice effecting CFF.

INTEGER :: i_pc2_conv_coupling = imdi  ! Integer option to determine how the
                                       ! PC2 cloud scheme and the convection
                                       ! scheme are coupled and how cloud gets
                                       ! generated by convection.

INTEGER :: i_pc2_erosion_method = imdi ! Select method for calculating
                                       ! PC2 cloud erosion.

INTEGER :: forced_cu = imdi            ! Select option for representing
                                       ! forced cumulus

INTEGER :: i_rhcpt = imdi              ! Controls the use of RHcrit
                                       ! parametrization options
INTEGER :: i_cld_area  = imdi          ! Controls cloud area parametrization

INTEGER :: i_pc2_checks_cld_frac_method = imdi  ! Options for changing CFL and CF
                                       ! when creating extra
                                       ! QCL when qv>qsat.

INTEGER, PARAMETER :: all_clouds = 1   ! Use eacf for all cloud fractions
INTEGER, PARAMETER :: not_mixph = 2    ! Restrict usage in mixed-phase regions
INTEGER :: i_eacf = imdi               ! Use empirically adjusted
                                       ! cloud fraction

INTEGER, PARAMETER :: smith_orig = 1      ! original smith scheme method for
                                          ! ice cloud fraction method
INTEGER, PARAMETER :: cloud_top_temp = 2  ! Wilson method based on cloud top
                                          ! temperature (not recommended)
INTEGER, PARAMETER :: min_liq_overlap = 3 ! method in appendix of Abel et al
                                          ! (2017, JAS), based on minimising
                                          ! the overlap with the liquid phase
INTEGER :: ice_fraction_method = imdi     ! Selects ice cloud fraction
                                          ! calculation method
!===========================================================================
! LOGICAL options set from RUN_CLOUD namelist
!===========================================================================

LOGICAL :: l_ensure_min_in_cloud_qcf = .FALSE.
                                 ! Reduce CFF when qcf is low to
                                 ! ensure a minimum qcf/CFF.
LOGICAL :: l_fixbug_pc2_mixph = .FALSE.
                                 ! Collection of bug-fixes related
                                 ! to how PC2 treats mixed phase
                                 ! cloud fraction
LOGICAL :: l_micro_eros = .FALSE.
                                 ! If false, erosion is done as part of
                                 ! the convection scheme
                                 ! If true, erosion is done as part of
                                 ! the microphysics scheme

LOGICAL :: l_pc2_lbc = .FALSE.   ! LBCs contain cloud fractions

LOGICAL :: l_add_cca_to_mcica = .FALSE.
                                 ! Add the convective cloud amount to McICA
                                 ! so that radiation sees the convective cores.

LOGICAL :: l_od_cld_filter = .FALSE.
                                 ! Filters area and combined cloud amounts
                                 ! to remove sub-visual cirrus 
                                 ! (based on optical depth, od) prior to
                                 ! calculating low/med/high and
                                 ! total cloud amounts.
LOGICAL :: l_ceil_cld_filter=.FALSE.
                                 ! Filters cloud that cannot be seen by 
                                 ! ceilometers simply setting cloud cover to
                                 ! zero above the maximum height ceilometers 
                                 ! can detect them. The height is set by
                                 ! "ceilometer_range" below.
LOGICAL :: l_sharpen_cbh_diags=.FALSE.
                                 ! Modify the CBH diagnostics in a manner
                                 ! consistent with sharpening the humidity PDF
                                 ! and with sharpening the clear/cloud boundary
LOGICAL :: l_pc2_check_init=.FALSE.
                                 ! Always run pc2_checks when the model is
                                 ! initialised
LOGICAL :: l_subgrid_qv=.FALSE.
                                 ! Allow subgrid partitioning of water vapor
                                 ! between clear-sky and sublimating/depositing
                                 ! ice-cloud regions. This is used in the
                                 ! microphysics to calculate the processes rates

LOGICAL :: l_simplify_pc2_init_logic=.FALSE.
                                 ! Simplify the logic around deciding when to
                                 ! do pc2 initiation.
LOGICAL, PARAMETER :: l_inc_cld_prec=.TRUE.
                                 ! Allow call to the Smith cloud scheme from 
                                 ! within the large-scale precipitation scheme. 

LOGICAL :: l_acure_dbsdtbs_turb_0= .FALSE.
                                 ! Logical switch to enable perturbation in the
                                 ! ACURE PPE. Added for consistancy. Probably
                                 ! disused in code

!=======================================================================
! REAL values set from RUN_CLOUD namelist
!=======================================================================

REAL    :: dbsdtbs_turb_0 = rmdi      ! PC2 erosion rate / s-1
REAL    :: starticeTKelvin = rmdi   ! Temperature at which detrained
                                      ! condensate is assumed to start
                                      ! being in the ice phase (Kelvin)
REAL    :: alliceTdegC = rmdi        ! Temperature at which all
                                      ! detrained condensate is
                                      ! assumed to be ice (deg C)
REAL    :: cff_spread_rate = rmdi   ! Rate at which CFF spreads out.
REAL    :: rhcrit(model_levels_max) = rmdi
                                      ! Critical relative humidity

REAL    :: ice_width = rmdi           ! Specifies the ice content
                                      ! (in terms of a fraction of qsat_liq)
                                      ! that corresponds to a factor of
                                      ! two reduction in the width of
                                      ! the vapour distribution in the
                                      ! liquid-free part of the gridbox.
REAL    :: tau_thresh = 0.01          ! Value of optical depth below
                                      ! which ice cloud is set to zero.
REAL    :: forced_cu_fac = rmdi       ! Factor to tune in-cloud water 
                                      ! content for forced cu
!=======================================================================
! Constants, removed from RUN_CLOUD namelist
!=======================================================================
INTEGER :: cloud_fraction_method   = 1
                                       ! Selects total cloud fraction
                                       ! calculation method
                                       ! 1 = minimum overlap
                                       ! 2 = variable overlap, controlled
                                       ! by overlap_ice_liquid

REAL    :: overlap_ice_liquid = -1.0
                                      ! Generic overlap parameter
                                      ! between ice and liquid phases
REAL    :: ctt_weight = 0.333
                                      ! Cloud top temperature weight
REAL    :: t_weight = 0.333
                                      ! Local temperature weight
REAL    :: qsat_fixed = 0.1e-3        ! Prescribed qsat value
REAL    :: sub_cld   = 0.225          ! Scaling factor
REAL    :: ceilometer_range = 6.0e3   ! Max range of ceilometers used
                                      ! in filtered cloud diagnostics

!=======================================================================
! Control options, removed from namelist
!=======================================================================

LOGICAL :: l_pc2_reset = .FALSE. ! Run PC2 scheme diagnostically

LOGICAL :: l_fixbug_pc2_qcl_incr = .TRUE.
                                 ! Prevent QCL incr removing more
                                 ! QCL than there is, down at the
                                 ! individual subroutine level.

!----------------------------------------------------------------------
!
!----------------------------------------------------------------------

! Define the RUN_CLOUD namelist

NAMELIST/RUN_Cloud/ rhcrit, i_eacf, forced_cu, forced_cu_fac,          &
       dbsdtbs_turb_0, falliceshear_method,                            &
       l_ensure_min_in_cloud_qcf, l_fixbug_pc2_mixph,                  &
       i_pc2_conv_coupling, i_pc2_erosion_method, l_micro_eros,        &
       starticeTKelvin, alliceTdegC, cff_spread_rate, ice_width,       &
       i_cld_area, i_cld_vn, l_pc2_lbc, i_rhcpt,                       &
       l_add_cca_to_mcica,                                             &
       l_od_cld_filter, tau_thresh,                                    &
       l_ceil_cld_filter, l_sharpen_cbh_diags, l_pc2_check_init,       &
       l_subgrid_qv, i_pc2_checks_cld_frac_method,                     &
       l_simplify_pc2_init_logic, ice_fraction_method,                 &
       l_acure_dbsdtbs_turb_0

!DrHook-related parameters
INTEGER(KIND=jpim), PARAMETER, PRIVATE :: zhook_in  = 0
INTEGER(KIND=jpim), PARAMETER, PRIVATE :: zhook_out = 1

CHARACTER(LEN=*), PARAMETER, PRIVATE :: ModuleName='CLOUD_INPUTS_MOD'

CONTAINS

SUBROUTINE check_run_cloud()

! Description:
!   Subroutine to apply logic checks based on the options selected in
!   the run_cloud namelist.

USE bl_option_mod, ONLY: off
USE ereport_mod,    ONLY: ereport
USE pc2_constants_mod, ONLY: acf_off, acf_cusack, acf_brooks,       &
       rhcpt_off, rhcpt_horiz_var, rhcpt_tke_based, i_cld_pc2,      &
       i_cld_off, i_cld_smith
USE chk_opts_mod, ONLY: chk_var, def_src

IMPLICIT NONE

INTEGER                       :: icode         ! used for ereport
CHARACTER (LEN=errormessagelength)      :: cmessage      ! used for ereport
CHARACTER (LEN=*), PARAMETER  :: RoutineName = 'CHECK_RUN_CLOUD'

REAL(KIND=jprb)               :: zhook_handle

IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)
def_src = RoutineName

! check the cloud scheme chosen is sensible
CALL chk_var(i_cld_vn,'i_cld_vn',[i_cld_off,i_cld_smith,i_cld_pc2])

IF (i_cld_vn > i_cld_off) THEN
  CALL chk_var(i_cld_area,'i_cld_area',[acf_off,acf_cusack,acf_brooks])
END IF

CALL chk_var(i_rhcpt,'i_rhcpt',[rhcpt_off,rhcpt_horiz_var,rhcpt_tke_based])

CALL chk_var(ice_fraction_method,'ice_fraction_method',                 &
     [smith_orig,cloud_top_temp,min_liq_overlap])

IF (i_cld_vn /= i_cld_pc2) THEN
  forced_cu = off
  cmessage =                                                        &
  'WARNING: forced_cu set to off since pc2 is off'
  icode = -100
  CALL ereport(RoutineName, icode, cmessage)

  CALL chk_var(i_eacf,'i_eacf',[0,all_clouds,not_mixph])
END IF

def_src = ''
IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)
RETURN
END SUBROUTINE check_run_cloud

SUBROUTINE print_nlist_run_cloud()
USE nlsizes_namelist_mod, ONLY: model_levels
USE umPrintMgr, ONLY: umPrint
IMPLICIT NONE
CHARACTER(LEN=50000) :: lineBuffer
REAL(KIND=jprb)      :: zhook_handle
INTEGER              :: i, rh_lev

CHARACTER(LEN=*), PARAMETER :: RoutineName='PRINT_NLIST_RUN_CLOUD'

IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)

CALL umPrint('Contents of namelist run_cloud', &
    src='cloud_inputs_mod')
IF (model_levels > 0) THEN ! model_levels has been set
  WRITE(lineBuffer,'(A,I0)')' For Reference: model_levels = ',model_levels
  CALL umPrint(lineBuffer,src='cloud_inputs_mod')
  DO i = 1,(model_levels+7)/8
    WRITE(lineBuffer,'(A,I0,A,I0,A,8(F0.5,1X))') ' lev ',8*i-7,'-',8*i, &
                     ' rhcrit=',rhcrit(8*i-7:8*i)
    CALL umPrint(lineBuffer,src='cloud_inputs_mod')
  END DO
ELSE ! model_levels not yet read
  rh_lev = COUNT(rhcrit /= rmdi)
  WRITE(lineBuffer,'(A,I0)')' For Reference: no. of rhcrit inputs = ',rh_lev
  CALL umPrint(lineBuffer,src='cloud_inputs_mod')
  DO i = 1,(rh_lev+7)/8
    WRITE(lineBuffer,'(A,I0,A,I0,A,8(F0.5,1X))') ' lev ',8*i-7,'-',8*i, &
                     ' rhcrit=',rhcrit(8*i-7:8*i)
    CALL umPrint(lineBuffer,src='cloud_inputs_mod')
  END DO
END IF
WRITE(lineBuffer,'(A,I0)')' i_eacf = ',i_eacf
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,I0)')' forced_cu = ',forced_cu
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,F0.4)')' forced_cu_fac = ',forced_cu_fac
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,F0.4)')' dbsdtbs_turb_0 = ',dbsdtbs_turb_0
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,I0)')' falliceshear_method = ',falliceshear_method
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,L1)')' l_ensure_min_in_cloud_qcf = ',  &
                            l_ensure_min_in_cloud_qcf
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,L1)')' l_fixbug_pc2_mixph = ',l_fixbug_pc2_mixph
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,L1)')' l_pc2_check_init = ',l_pc2_check_init
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,I0)')' i_pc2_conv_coupling = ',i_pc2_conv_coupling
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,I0)')' i_pc2_erosion_method = ',i_pc2_erosion_method
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,L1)')' l_micro_eros = ',l_micro_eros
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,F0.4)')' starticeTKelvin = ',starticeTKelvin
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,F0.4)')' alliceTdegC = ',alliceTdegC
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,F0.4)')' cff_spread_rate = ',cff_spread_rate
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,F0.4)')' ice_width = ',ice_width
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,I0)')' i_cld_area = ',i_cld_area
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,I0)')' i_cld_vn = ',i_cld_vn
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,L1)')' l_pc2_lbc = ',l_pc2_lbc
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,I0)')' i_rhcpt = ',i_rhcpt
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,L1)')' l_add_cca_to_mcica = ',l_add_cca_to_mcica
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,L1)')' l_od_cld_filter = ',l_od_cld_filter
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,F0.4)')' tau_thresh = ',tau_thresh
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,L1)')' l_ceil_cld_filter = ',l_ceil_cld_filter
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,L1)')' l_sharpen_cbh_diags = ',l_sharpen_cbh_diags
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,L1)')' l_subgrid_qv = ',l_subgrid_qv
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,I0)')' i_pc2_checks_cld_frac_method = ',  &
                             i_pc2_checks_cld_frac_method
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,L1)')' l_simplify_pc2_init_logic = ',  &
                            l_simplify_pc2_init_logic
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,I0)')' ice_fraction_method = ',ice_fraction_method
CALL umPrint(lineBuffer,src='cloud_inputs_mod')
WRITE(lineBuffer,'(A,L1)')'  l_acure_dbsdtbs_turb_0 = ', l_acure_dbsdtbs_turb_0
CALL umPrint(lineBuffer,src='cloud_inputs_mod')

CALL umPrint('- - - - - - end of namelist - - - - - -', &
    src='cloud_inputs_mod')

IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)

END SUBROUTINE print_nlist_run_cloud

#if !defined(LFRIC)
SUBROUTINE read_nml_run_cloud(unit_in)

USE um_parcore, ONLY: mype

USE check_iostat_mod, ONLY: check_iostat

USE setup_namelist, ONLY: setup_nml_type

IMPLICIT NONE

INTEGER,INTENT(IN) :: unit_in
INTEGER :: my_comm
INTEGER :: mpl_nml_type
INTEGER :: ErrorStatus
INTEGER :: icode
CHARACTER(LEN=errormessagelength) :: iomessage
REAL(KIND=jprb) :: zhook_handle

CHARACTER(LEN=*), PARAMETER :: RoutineName='READ_NML_RUN_CLOUD'

! set number of each type of variable in my_namelist type
INTEGER, PARAMETER :: no_of_types = 3
INTEGER, PARAMETER :: n_int = 10
INTEGER, PARAMETER :: n_real = 7 + model_levels_max
INTEGER, PARAMETER :: n_log = 11

TYPE my_namelist
  SEQUENCE
  INTEGER :: i_cld_vn
  INTEGER :: forced_cu
  INTEGER :: falliceshear_method
  INTEGER :: i_pc2_conv_coupling
  INTEGER :: i_pc2_erosion_method
  INTEGER :: i_cld_area
  INTEGER :: i_rhcpt
  INTEGER :: i_pc2_checks_cld_frac_method
  INTEGER :: i_eacf
  INTEGER :: ice_fraction_method
  REAL :: rhcrit(model_levels_max)
  REAL :: dbsdtbs_turb_0
  REAL :: starticeTKelvin
  REAL :: alliceTdegC
  REAL :: cff_spread_rate
  REAL :: ice_width
  REAL :: tau_thresh
  REAL :: forced_cu_fac
  LOGICAL :: l_ensure_min_in_cloud_qcf
  LOGICAL :: l_fixbug_pc2_mixph
  LOGICAL :: l_micro_eros
  LOGICAL :: l_pc2_lbc
  LOGICAL :: l_add_cca_to_mcica
  LOGICAL :: l_od_cld_filter
  LOGICAL :: l_ceil_cld_filter
  LOGICAL :: l_sharpen_cbh_diags
  LOGICAL :: l_pc2_check_init
  LOGICAL :: l_subgrid_qv
  LOGICAL :: l_simplify_pc2_init_logic
  LOGICAL :: l_acure_dbsdtbs_turb_0
END TYPE my_namelist

TYPE (my_namelist) :: my_nml

IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)

CALL gc_get_communicator(my_comm, icode)

CALL setup_nml_type(no_of_types, mpl_nml_type, n_int_in=n_int,     &
                    n_real_in=n_real, n_log_in=n_log)

IF (mype == 0) THEN

  READ(UNIT=unit_in, NML=RUN_Cloud, IOSTAT=ErrorStatus, IOMSG=iomessage)
  CALL check_iostat(errorstatus, "namelist RUN_Cloud", iomessage)

  my_nml % i_cld_vn              = i_cld_vn
  my_nml % forced_cu             = forced_cu
  my_nml % falliceshear_method   = falliceshear_method
  my_nml % i_pc2_conv_coupling   = i_pc2_conv_coupling
  my_nml % i_pc2_erosion_method  = i_pc2_erosion_method
  my_nml % i_cld_area            = i_cld_area
  my_nml % i_rhcpt               = i_rhcpt
  my_nml % i_pc2_checks_cld_frac_method   = i_pc2_checks_cld_frac_method
  my_nml % i_eacf                = i_eacf
  my_nml % ice_fraction_method   = ice_fraction_method
  ! end of integers
  my_nml % rhcrit                = rhcrit
  my_nml % dbsdtbs_turb_0        = dbsdtbs_turb_0
  my_nml % starticeTKelvin       = starticeTKelvin
  my_nml % alliceTdegC           = alliceTdegC
  my_nml % cff_spread_rate       = cff_spread_rate
  my_nml % ice_width             = ice_width
  my_nml % tau_thresh            = tau_thresh
  my_nml % forced_cu_fac         = forced_cu_fac
  ! end of reals
  my_nml % l_ensure_min_in_cloud_qcf = l_ensure_min_in_cloud_qcf
  my_nml % l_fixbug_pc2_mixph    = l_fixbug_pc2_mixph
  my_nml % l_micro_eros          = l_micro_eros
  my_nml % l_pc2_lbc             = l_pc2_lbc
  my_nml % l_add_cca_to_mcica    = l_add_cca_to_mcica
  my_nml % l_od_cld_filter       = l_od_cld_filter
  my_nml % l_ceil_cld_filter     = l_ceil_cld_filter
  my_nml % l_sharpen_cbh_diags   = l_sharpen_cbh_diags
  my_nml % l_pc2_check_init      = l_pc2_check_init
  my_nml % l_subgrid_qv          = l_subgrid_qv
  my_nml % l_simplify_pc2_init_logic = l_simplify_pc2_init_logic
  my_nml % l_acure_dbsdtbs_turb_0    = l_acure_dbsdtbs_turb_0
END IF

CALL mpl_bcast(my_nml,1,mpl_nml_type,0,my_comm,icode)

IF (mype /= 0) THEN

  i_cld_vn                = my_nml % i_cld_vn
  forced_cu               = my_nml % forced_cu
  falliceshear_method     = my_nml % falliceshear_method
  i_pc2_conv_coupling     = my_nml % i_pc2_conv_coupling
  i_pc2_erosion_method    = my_nml % i_pc2_erosion_method
  i_cld_area              = my_nml % i_cld_area
  i_rhcpt                 = my_nml % i_rhcpt
  i_pc2_checks_cld_frac_method = my_nml % i_pc2_checks_cld_frac_method
  i_eacf                  = my_nml % i_eacf
  ice_fraction_method     = my_nml % ice_fraction_method
  ! end of integers
  rhcrit                  = my_nml % rhcrit
  dbsdtbs_turb_0          = my_nml % dbsdtbs_turb_0
  starticeTKelvin         = my_nml % starticeTKelvin
  alliceTdegC             = my_nml % alliceTdegC
  cff_spread_rate         = my_nml % cff_spread_rate
  ice_width               = my_nml % ice_width
  tau_thresh              = my_nml % tau_thresh
  forced_cu_fac           = my_nml % forced_cu_fac
  ! end of reals
  l_ensure_min_in_cloud_qcf = my_nml % l_ensure_min_in_cloud_qcf
  l_fixbug_pc2_mixph      = my_nml % l_fixbug_pc2_mixph
  l_micro_eros            = my_nml % l_micro_eros
  l_pc2_lbc               = my_nml % l_pc2_lbc
  l_add_cca_to_mcica      = my_nml % l_add_cca_to_mcica
  l_od_cld_filter         = my_nml % l_od_cld_filter
  l_ceil_cld_filter       = my_nml % l_ceil_cld_filter
  l_sharpen_cbh_diags     = my_nml % l_sharpen_cbh_diags
  l_pc2_check_init        = my_nml % l_pc2_check_init
  l_subgrid_qv            = my_nml % l_subgrid_qv
  l_simplify_pc2_init_logic = my_nml % l_simplify_pc2_init_logic
  l_acure_dbsdtbs_turb_0    = my_nml % l_acure_dbsdtbs_turb_0
END IF

CALL mpl_type_free(mpl_nml_type,icode)

IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)

END SUBROUTINE read_nml_run_cloud
#endif

END MODULE cloud_inputs_mod
